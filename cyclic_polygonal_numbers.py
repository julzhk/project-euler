#!/usr/bin/env python3
#
# https://projecteuler.net/problem=61
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
# all figurate (polygonal) numbers and are generated by the following formulae:
#
# Triangle          P(3,n) = n(n + 1)/2           1, 3, 6, 10, 15, ...
# Square            P(4,n) = n^2                  1, 4, 9, 16, 25, ...
# Pentagonal        P(5,n) = n(3n − 1)/2          1, 5, 12, 22, 35, ...
# Hexagonal         P(6,n) = n(2n − 1)            1, 6, 15, 28, 45, ...
# Heptagonal        P(7,n) = n(5n − 3)/2          1, 7, 18, 34, 55, ...
# Octagonal         P(8,n) = n(3n − 2)            1, 8, 21, 40, 65, ...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
# interesting properties.
#
#    1. The set is cyclic, in that the last two digits of each number is the
#    first two digits of the next number (including the last number with the
#    first).
#    2. Each polygonal type: triangle (P(3,127) = 8128), square
#    (P(4,91) = 8281), and pentagonal (P(5,44) = 2882), is represented by a
#    different number in the set.
#    3. This is the only set of 4-digit numbers with this property.
#
# The Project Eulier problem of finding the a 2-cyclic set of six 4-digit
# integers which contains exactly one number each of type triangular, square,
# pentagonal, hexagonal, heptagonal, and octagonal, is computationally out of
# bounds (there are approximately 943 billion candidates). So I've chosen here
# to implement the search for a 2-cyclic set of three 4-digit integers which
# contains exactly one each of type triangular, square and pentagonal, which is
# the example given above.

from itertools import combinations

from math import factorial

from utils import (
    is_d_cyclic_set,
    is_polygonal_number,
    is_polygonal_representative_set,
)

from time import sleep

if __name__ == '__main__':
    k = 3   # no. of integers in the result set
    v = 4   # number of digits in each integer
    d = 2   # degree of cyclicity of the set, e.g. 2-cyclic, 3-cyclic etc.
    poly_reps = {3, 4, 5}  # the type or degree of polynomial numbers to search for
    candidates = [m for m in range(10**3, 10**4) if any(is_polygonal_number(m, n) for n in poly_reps)]
    c = len(candidates)
    s = int(factorial(c) / (factorial(k)*factorial(c-k)))
    result_set = None
    print(
        '\nSearching for a {}-cyclic set of {} {}-digit integers which is '
        '{}-polygonal representative ...\n'.format(d, k, v, poly_reps)
    )
    sleep(3)

    print(
        '\nThis could take a while as there are {} sets of three '
        '4-digit integers, each containing a triangular, square or pentagonal '
        'number.\n'.format(s)
    )
    sleep(3)
    
    for i, int_set in enumerate(combinations(candidates, 3)):
        print('\t#{}. Checking if {} is {}-cyclic and {}-polygonal representative: '.format(i, int_set, d, poly_reps), end='')
        is_d_cyclic = is_d_cyclic_set(int_set, d)
        has_poly_reps = is_polygonal_representative_set(int_set, poly_reps)
        if is_d_cyclic and has_poly_reps:
            result_set = int_set
            print('YES')
            break
        else:
            print('NO: {}-cyclic={}, is {}-polygonal representative={}'.format(d, is_d_cyclic, poly_reps, has_poly_reps))

    sleep(3)
    if result_set:
        result_set = sorted(result_set)
        tr, sq, pn = (m for m in result_set if any(is_polygonal_number(m, n) for n in poly_reps))
    print(
        '\nThe set {} is {}-cyclic and {}-polygonal representative: {} is '
        'triangular, {} is square, {} is pentagonal.'
        .format(set(result_set), d, poly_reps, tr, sq, pn)
    )
